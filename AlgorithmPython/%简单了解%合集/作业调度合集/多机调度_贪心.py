# -*- coding: utf-8 -*-
# 这便是调度问题的比较一般化的形态, 类似背包和01背包的关系
# 这个目录下的调度问题期末考试概率小
# 设有n个独立的作业{1, 2, …, n}，由m台相同的机器{M1, M2, …, Mm}进行加工处理，作业i所需的处理时间为ti（1≤i≤n），每个作业均可在任何一台机器上加工处理，但不可间断、拆分。
# 多机调度问题要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成

# 类似的, 这类问题一般解法比较困难(类似TSP问题), 一般用贪心算法求近似解
# 贪心法求解多机调度问题的贪心策略是最长处理时间作业优先，即把处理时间最长的作业分配给最先空闲的机器，这样可以保证处理时间长的作业优先处理，从而在整体上获得尽可能短的处理时间。
# 按照最长处理时间作业优先的贪心策略，当m≥n时，只要将机器i的[0, ti)时间区间分配给作业i即可；当m＜n时，首先将n个作业依其所需的处理时间从大到小排序，然后依此顺序将作业分配给空闲的处理机。
# 参考了 https://blog.csdn.net/weixin_42260102/article/details/95971105 大佬的文章

tasks = [2, 14, 4, 6, 16, 5, 3]
machine = 3
machines = [0] * machine  # 初始化m台机器的任务时间为0


def schedule(t):
    global machines
    t.sort(reverse=True)

    for task in t:
        min_machine = machines.index(min(machines))  # 找到当前最先空闲的机器
        machines[min_machine] += task  # 将任务分配给该机器，并更新机器的任务时间

    return max(machines)  # 返回所有机器中最大的任务时间，即完成时间


# 调用函数并打印结果
print(schedule(tasks))
